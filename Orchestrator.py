#################################################################
#																#
# -Project:		Prevalence of Types of ASEPs in Windows malware #
# -File:		Orchestrator.py									#
# -Author:		Carlos Borau GonzÃ¡lez | NIP: 778280				#
# -Description: Malware sample analysis workflow orchestrator	#
#					responsible for the coordination among the  #
#					multiple processes invlolved in this task:	#
#					-Sample Digestion							#
#					-Sample Submission for Analysis				#
#					-Analysis Logs Gathering					#
#					-Analysis Logs Parsing and Sample Labeling	#
#					-Analysis Logs, Results and Sample Storing	#
#																#
#################################################################

# Workflow components imports
from Digester 	import Digester
from Analyzer 	import Analyzer,	AnalyzerMode
from Labeler	import Labeler,		LabelerMode
from Storer		import Storer

# Utility imports
import queue
import time
import sys
from multiprocessing import Process, Value, Manager

# RPC comunication imports
import xmlrpc.server as srv
import xmlrpc.client as cli


class Orchestrator:

	
	def __init__(self, overwatch_directory, samples_directory, results_directory,
	 processed_hashes=[], remoteAnalysis=False, remoteLabeling=True):
	
		self.AnalyzerMode = AnalyzerMode.Remote if remoteAnalysis else AnalyzerMode.Local
		self.LabelerMode  = LabelerMode.Remote  if remoteLabeling else LabelerMode.Local
		
		self.Digester = Digester(overwatch_directory, samples_directory, processed_hashes)
		self.Digester.start(60)
		
		self.Storer = Storer(results_directory)
		
		self.ResourceManager = Manager()
		
		self.WorkersID = Value('i', 0)
		self.Workers = dict()
		self.WorkersLock = self.ResourceManager.Lock()
		
		# Analysis Workers Settings		
		self.AnalysisWorkersSample = self.ResourceManager.dict()
		self.AnalysisWorkersFinish = self.ResourceManager.dict()
		self.AnalysisWorkersIsDone = self.ResourceManager.dict()
		self.AnalysisWorkersHBMiss = self.ResourceManager.dict()
		
		# Labeling Workers Settings	
		self.LabelingWorkersID_Log = self.ResourceManager.dict()
		self.LabelingWorkersFinish = self.ResourceManager.dict()
		self.LabelingWorkersIsDone = self.ResourceManager.dict()
		self.LabelingWorkersHBMiss = self.ResourceManager.dict()
		
		self.AvailableLogs = self.ResourceManager.Queue()
		
		if remoteAnalysis or remoteLabeling:
			self.HBMonitorProcess = Process(target=self.HeartBeatMonitor, args=())
			self.HBMonitorProcess.start()
		
		
	def stop(self):
	
		self.Digester.stop()
		
		if self.AnalyzerMode == AnalyzerMode.Remote or self.LabelerMode == LabelerMode.Remote:
			self.HBMonitorProcess.terminate()
			self.HBMonitorProcess.join()
		
		for worker in self.LabelingWorkersID_Log.keys():
			self.delLabelingWorker(worker)
		
		for worker in self.AnalysisWorkersSample.keys():
			sample = self.delAnalysisWorker(worker)
			if sample != None:
				sampleID = self.Storer.SampleID(self.Storer.SampleName(sample))
				self.Storer.StoreSample(sampleID)
			
		self.WorkersLock.acquire()
		for worker in self.Workers.values():
			worker.join()
		self.WorkersLock.release()
			
		print("Sample logs yet to be labeled: ")
		
		try:
			while(True):
				resource = self.AvailableLogs.get(False)
				print("\t" + resource[0])
		except queue.Empty:
			print("Done")
		
		
	#########################################################
	#														#
	#			  Heartbeat Monitoring Process				#
	#														#
	#########################################################
	
	
	def HeartBeatMonitor(self):
	
		try:
	
			while(True):
			
				lA = [self.AnalysisWorkersSample, self.AnalysisWorkersHBMiss]
				dA = dict()
			
				if self.AnalyzerMode == AnalyzerMode.Remote:
					for ID in self.AnalysisWorkersSample.keys():
					
						dA[ID] = tuple(d[ID] for d in lA)
						
						if self.AnalysisWorkersIsDone[ID]:
							self.AnalysisWorkersSample.pop(ID, None)
							self.AnalysisWorkersFinish.pop(ID, None)
							self.AnalysisWorkersIsDone.pop(ID, None)
							self.AnalysisWorkersHBMiss.pop(ID, None)
							
						elif self.AnalysisWorkersHBMiss[ID] >= 5:
							
							self.AnalysisWorkersFinish[ID] = True
							
						else:
							self.AnalysisWorkersHBMiss[ID] += 1
							
				lL = [self.LabelingWorkersID_Log, self.LabelingWorkersHBMiss]
				dL = dict()
				
				if self.LabelerMode == LabelerMode.Remote:
					for ID in self.LabelingWorkersID_Log.keys():
					
						dL[ID] = tuple(d[ID] for d in lL)
						
						if self.LabelingWorkersIsDone[ID]:
							self.LabelingWorkersID_Log.pop(ID, None)
							self.LabelingWorkersFinish.pop(ID, None)
							self.LabelingWorkersIsDone.pop(ID, None)
							self.LabelingWorkersHBMiss.pop(ID, None)
							
						elif self.LabelingWorkersHBMiss[ID] >= 5:
							
							self.LabelingWorkersFinish[ID] = True
							
						else:
						
							self.LabelingWorkersHBMiss[ID] += 1
							
				print(dA, dL)
						
				time.sleep(30)
			
		except KeyboardInterrupt:
		
			pass
			
			
	#########################################################
	#														#
	#					Analysis Workers					#
	#														#
	#########################################################
			
	def analysisWorkerProcess(self, ID, addr):
	
		try:
	
			if(self.AnalyzerMode == AnalyzerMode.Local):
				analyzer = Analyzer(AnalyzerMode.Local)
				analyzer.Start()
			else:
				analyzer = cli.ServerProxy('http://{0}'.format(addr))
				time.sleep(5)
				analyzer.system.listMethods()
				
			finished = self.AnalysisWorkersFinish[ID]
			
			while(not finished):
			
				# Get sample to analyze
				sample = self.Digester.getSample()
				
				if sample == None:
					finished = self.AnalysisWorkersFinish[ID]
					continue
					
				self.AnalysisWorkersSample[ID] = sample
				
				# Submit sample to analyzer
				analysisTask = analyzer.SubmitSample(sample)
				
				print("Analysis worker {0} analyzing sample {1} with task ID {2}".format(ID, sample, analysisTask))
				
				# Wait for the analysis to be completed
				while(analyzer.CheckStatus(analysisTask) == "pending"):
					print("Analysis worker {0} analyzing sample {1}. Pending results".format(ID, sample), end='\r', flush=True)
					time.sleep(30)
					
				if(analyzer.CheckStatus(analysisTask) == "done"):
					# Analysis completed -> Request Logs and queue them to be parsed
					
					availableLogs = analyzer.AvailableLogs(analysisTask)
					
					sampleID = self.Storer.CreateSampleTmpDir(sample)
					
					if(availableLogs):
					
						print("Analysis worker {0} completed sample {1}. Logs generated:".format(ID, sample), availableLogs)
					
						# Check drakrun log
						log_content = analyzer.GetLog(analysisTask, "drakrun") if ("drakrun" in availableLogs) else ""
							
						if(log_content):
							# Drakrun log properly generated
							self.Storer.CreateSampleResource(sampleID, "drakrun.log", log_content)
							
							# Check syscall log
							log_content = analyzer.GetLog(analysisTask, "syscall") if ("syscall" in availableLogs) else ""
							
							if(log_content):
								# Syscall log properly generated
								logPath = self.Storer.CreateSampleResource(sampleID, "syscall.log", log_content)
								
								# Queue the log to be parsed and labeled by a labeling worker
								self.AvailableLogs.put((sampleID, logPath))
							
							else:
								# Tried but failed to analyze the sample
								self.Storer.StoreSample(sampleID)
							
					else:
						# Analysis failure -> No logs generated
						log_content = "Analysis Failure | NO_LOGS_GENERATED"
						self.Storer.CreateSampleResource(sampleID, "INFO.log", log_content)
						self.Storer.StoreSample(sampleID)
						
				else:
					# Analysis failure -> Requeue the sample to be analyzed later
					print("Analysis worker {0} completed sample {1}. Analysis not done".format(ID, sample))
					self.Digester.putSample(sample)
					
				# Marked for finish?
				finished = self.AnalysisWorkersFinish[ID]
				self.AnalysisWorkersSample[ID] = None
				
			self.AnalysisWorkersIsDone[ID] = True
				
		except KeyboardInterrupt:
			# Shutting down
			pass
			
		except Exception as e:
			# Something went wrong -> Requeue the sample to be analyzed later
			
			sample = self.AnalysisWorkersSample[ID]
			if sample != None: self.Digester.putSample(sample)
			
			self.AnalysisWorkersIsDone[ID] = True
			
			print(repr(e))
			
		finally:
			if self.AnalyzerMode == AnalyzerMode.Local: analyzer.Stop()
			print("Analysis worker with ID: {0} exiting".format(ID))
			
		
	def addAnalysisWorker(self, addr=None):
	
		if(self.AnalyzerMode == AnalyzerMode.Local):
		
			# New local process
			ID = self.WorkersID.value
			self.WorkersID.value += 1
			
		else:
		
			ID = addr
			
			if(ID in self.AnalysisWorkersSample): 
			
				# Fallen worker reconnects before heartbeat detection
				sample = delAnalysisWorker(ID)
				self.WorkersLock.acquire()
				p = self.Workers[ID]
				self.WorkersLock.release()
				p.join()
				if sample != None: self.Digester.putSample(sample)
		
		p = Process(target=self.analysisWorkerProcess, args=(ID,addr))
		
		self.AnalysisWorkersSample[ID] = None
		self.AnalysisWorkersFinish[ID] = False
		self.AnalysisWorkersIsDone[ID] = False
		self.AnalysisWorkersHBMiss[ID] = 0
		
		self.WorkersLock.acquire()
		self.Workers[ID] = p
		self.WorkersLock.release()
		
		p.start()
		
		return ID
	
	
	def delAnalysisWorker(self, ID):
	
		if ID in self.AnalysisWorkersSample:
			self.AnalysisWorkersFinish[ID] = True
			return self.AnalysisWorkersSample[ID]
			
		return None	
	
	
	def registerAnalysisWorkerHeartbeat(self, ID):
	
		if ID in self.AnalysisWorkersSample:
			self.AnalysisWorkersHBMiss[ID] = 0
		else:
			self.addAnalysisWorker(ID)
			
		
	def getAnalysisWorkers(self):
	
		workers = list(self.AnalysisWorkersSample.keys())
		return [w for w in workers if not self.AnalysisWorkersIsDone[w]]
		
		
	
	#########################################################
	#														#
	#					Labeling Workers					#
	#														#
	#########################################################
	
	def labelingWorkerProcess(self, ID, addr):
	
		try:
		
			if(self.LabelerMode == LabelerMode.Local):
				labeler = Labeler(LabelerMode.Local)
			else:
				labeler = cli.ServerProxy('http://{0}'.format(addr))
				time.sleep(5)
				labeler.system.listMethods()
			
			finished = self.LabelingWorkersFinish[ID]
			
			while(not finished):
			
				# Get log to parse
				try:
				
					resource = self.AvailableLogs.get(True, 15)
					(sampleID, log) = resource
					
				except queue.Empty:
				
					finished = self.LabelingWorkersFinish[ID]
					continue
					
				except ValueError:
				
					finished = self.LabelingWorkersFinish[ID]
					continue
					
				self.LabelingWorkersID_Log[ID] = resource
				
				print("labeling worker {0} labeling sample {1}".format(ID, sampleID))
				
				# Submit the log for parsing
				results = labeler.SubmitLog(log)

				# Create the corresponding resource for the sample and save it
				self.Storer.CreateSampleResource(sampleID, "labeling.log", results)
				self.Storer.StoreSample(sampleID)
			
				# Marked for stop?
				finished = self.LabelingWorkersFinish[ID]
				self.LabelingWorkersID_Log[ID] = None
				
			self.LabelingWorkersIsDone[ID] = True
				
		except KeyboardInterrupt:
			# Shutting down
			pass
					
		except Exception as e:
			# Something went wrong -> Requeue the log to be labeled later
			
			resource = self.LabelingWorkersID_Log[ID]
			if resource != None: self.AvailableLogs.put(resource)
			
			self.LabelingWorkersIsDone[ID] = True
			
			print(repr(e))
			
		finally:
		
			print("Labeling worker with ID: {0} exiting".format(ID))
			
	
	def addLabelingWorker(self, addr=None):
	
		if(self.LabelerMode == LabelerMode.Local):
		
			# New local process
			ID = self.WorkersID.value
			self.WorkersID.value += 1
			
		else:
			
			ID = addr
			
			if(ID in self.LabelingWorkersID_Log): 
			
				# Fallen worker reconnects before heartbeat detection
				resource = self.delLabelingWorker(ID)
				self.WorkersLock.acquire()
				p = self.Workers[ID]
				self.WorkersLock.release()
				p.join()
				if resource != None: self.AvailableLogs.put(resource)
		
		p = Process(target=self.labelingWorkerProcess, args=(ID,addr))
		
		self.LabelingWorkersID_Log[ID] = None
		self.LabelingWorkersFinish[ID] = False
		self.LabelingWorkersIsDone[ID] = False
		self.LabelingWorkersHBMiss[ID] = 0
		
		self.WorkersLock.acquire()
		self.Workers[ID] = p
		self.WorkersLock.release()
		
		p.start()
		
		return ID
	
	
	def delLabelingWorker(self, ID):
	
		if ID in self.LabelingWorkersID_Log:
			self.LabelingWorkersFinish[ID] = True
			return self.LabelingWorkersID_Log[ID]
		
		return None
	
	
	def registerLabelingWorkerHeartbeat(self, ID):
	
		if ID in self.LabelingWorkersID_Log:
			self.LabelingWorkersHBMiss[ID] = 0
		else:
			self.addLabelingWorker(ID)
	
	
	def getLabelingWorkers(self):
	
		workers = list(self.LabelingWorkersID_Log.keys())
		return [w for w in workers if not self.LabelingWorkersIsDone[w]]
		
