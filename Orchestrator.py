#################################################################
#																#
# -Project:		Prevalence of Types of ASEPs in Windows malware #
# -File:		Orchestrator.py									#
# -Author:		Carlos Borau GonzÃ¡lez | NIP: 778280				#
# -Description: Malware sample analysis workflow orchestrator	#
#					responsible for the coordination among the  #
#					multiple processes invlolved in this task:	#
#					-Sample Digestion							#
#					-Sample Submission for Analysis				#
#					-Analysis Logs Gathering					#
#					-Analysis Logs Parsing and Sample Labeling	#
#					-Analysis Logs, Results and Sample Storing	#
#																#
#################################################################

# Workflow components imports
from Digester 	import Digester
from Analyzer 	import Analyzer,	AnalyzerMode
from Labeler	import Labeler,		LabelerMode
from Storer		import Storer

# Utility imports
import time
from multiprocessing import Process, Value, Manager

# RPC comunication imports
import xmlrpc.server as srv
import xmlrpc.client as cli

# Auxiliar class to interact with worker threads
class WorkerHandler:

	def __init__(self, ID):
	
		self.ID = ID
		self.resource = None
		self.finish = False
		self.done = False
		self.HBMissCount = 0
		
	def __repr__(self):
	
		return self.__str__()
		
	def __str__(self):
	
		return "{Resource: " + str(self.resource) + " | HBMissed: " + str(self.HBMissCount) + "}"
		
	def HBMiss(self):
	
		self.HBMissCount += 1
		if self.HBMissCount >= 5:
			self.stop()
			
	def HBRegister(self):
	
		self.HBMissCount = 0
		
	def done(self):
	
		self.done = True
		
	def isDone(self):
		
		return self.done
		
	def markedForFinish(self):
		
		return self.finish
		
	def stop(self):
	
		self.finish = True		
		return self.resource
		
	def setResource(self, resource):
	
		self.resource = resource
		

class Orchestrator:

	
	def __init__(self, overwatch_directory, samples_directory, results_directory,
	 processed_hashes=[], remoteAnalysis=False, remoteLabeling=True):
	
		self.AnalyzerMode = AnalyzerMode.Remote if remoteAnalysis else AnalyzerMode.Local
		self.LabelerMode  = LabelerMode.Remote  if remoteLabeling else LabelerMode.Local
		
		self.Digester = Digester(overwatch_directory, samples_directory, processed_hashes)
		self.Digester.start(60)
		
		self.Storer = Storer(results_directory)
		
		self.ResourceManager = Manager()
		
		self.WorkersID = Value('i', 0)
		self.Workers = dict()
		self.WorkersLock = self.ResourceManager.Lock()
		self.AnalysisWorkers = self.ResourceManager.dict()
		self.LabelingWorkers = self.ResourceManager.dict()
		
		self.AvailableLogs = self.ResourceManager.Queue()
		
		if remoteAnalysis or remoteLabeling:
			self.HBMonitorProcess = Process(target=self.HeartBeatMonitor, args=())
			self.HBMonitorProcess.start()
		
		
	def stop(self):
	
		self.Digester.stop()
		
		if self.AnalyzerMode == AnalyzerMode.Remote or self.LabelerMode == LabelerMode.Remote:
			self.HBMonitorProcess.terminate()
			self.HBMonitorProcess.join()
		
		for worker in self.LabelingWorkers.values():
			self.delLabelingWorker(worker)
		
		for worker in self.AnalysisWorkers.values():
			sample = self.delAnalysisWorker(worker)
			sampleID = self.Storer.SampleID(self.Storer.SampleName(sample))
			self.Storer.StoreSample(sampleID)
			
		self.WorkersLock.acquire()
		for worker in self.Workers.values():
			worker.join()
		self.WorkersLock.release()
			
		print("Sample logs yet to be labeled: ", self.AvailableLogs)
		
		
	#########################################################
	#														#
	#			  Heartbeat Monitoring Process				#
	#														#
	#########################################################
	
	
	def HeartBeatMonitor(self):
	
		while(True):
		
			print(self.AnalysisWorkers, self.LabelingWorkers)
			
			if self.AnalyzerMode == AnalyzerMode.Remote:
				for ID, worker in self.AnalysisWorkers.items():
					if worker.isDone():
						self.AnalysisWorkers.pop(ID, None)
					else:
						worker.HBMiss()
						self.AnalysisWorkers[ID] = worker
			
			if self.LabelerMode == LabelerMode.Remote:
			
				for ID, worker in self.LabelingWorkers.items():
					if worker.isDone():
						self.LabelingWorkers.pop(ID, None)
					else:
						worker.HBMiss()
						self.LabelingWorkers[ID] = worker
					
			time.sleep(30)
			
			
	#########################################################
	#														#
	#					Analysis Workers					#
	#														#
	#########################################################
			
	def analysisWorkerProcess(self, ID, addr):
	
		try:
	
			if(self.AnalyzerMode == AnalyzerMode.Local):
				analyzer = Analyzer(AnalyzerMode.Local)
			else:
				analyzer = cli.ServerProxy('http://{0}'.format(addr))
				#analyzer.system.listMethods()
				
			finished = self.AnalysisWorkers[ID].markedForFinish()	
			
			while(not finished):
			
				# Get sample to analyze
				sample = self.Digester.getSample()
				worker = self.AnalysisWorkers[ID]
				worker.setResource(sample)
				self.AnalysisWorkers[ID] = worker
				
				print(sample)
				continue
				
				# Submit sample to analyzer
				analysisTask = analyzer.SubmitSample(sample)
				
				# Wait for the analysis to be completed
				while(analyzer.CheckStatus(analysisTask) == "pending"):
					time.sleep(30)
					
				if(analyzer.CheckStatus(analysisTask) == "done"):
					# Analysis completed -> Request Logs and queue them to be parsed
					availableLogs = analyzer.AvailableLogs(analysisTask)
					
					sampleID = self.storer.CreateSampleTmpDir(sample)
					
					if(availableLogs):
					
						# Check drakrun log
						log_content = analyzer.GetLog(analysisTask, "drakrun") if ("drakrun" in availableLogs) else ""
							
						if(log_content):
							# Drakrun log properly generated
							self.storer.CreateSampleResource(sampleID, "drakrun.log", log_content)
							
							# Check syscall log
							log_content = analyzer.GetLog(analysisTask, "syscall") if ("syscall" in availableLogs) else ""
							
							if(log_content):
								# Syscall log properly generated
								logPath = self.storer.CreateSampleResource(sampleID, "syscall.log", log_content)
								
								# Queue the log to be parsed and labeled by a labeling worker
								self.AvailableLogs.put((sampleID, logPath))
							
							else:
								# Tried but failed to analyze the sample
								self.storer.StoreSample(sampleID)
							
					else:
						# Analysis failure -> No logs generated
						log_content = "Analysis Failure | NO_LOGS_GENERATED"
						self.storer.CreateSampleResource(sampleID, "INFO.log", log_content)
						self.storer.StoreSample(sampleID)
						
						
				else:
					# Analysis failure -> Requeue the sample to be analyzed later
					self.Digester.putSample(sample)
					
				# Marked for finish?
				finished = self.AnalysisWorkers[ID].markedForFinish()
				self.AnalysisWorkers[ID].setResource(None)
			
			self.AnalysisWorkers[ID].done()
			
		except ConnectionRefusedError as err:
		
			# Worker Disconnection -> Requeue the sample to be analyzed later
			sample = self.delAnalysisWorker(ID)
			self.AnalysisWorkers[ID].done()
			if sample != None: self.Digester.putSample(sample)
			
		except OSError as err:
					
			# No route to Worker -> Requeue the sample to be analyzed later
			sample = self.delAnalysisWorker(ID)
			self.AnalysisWorkers[ID].done()
			if sample != None: self.Digester.putSample(sample)
		
		
	def addAnalysisWorker(self, addr=None):
	
		if(self.AnalyzerMode == AnalyzerMode.Local):
		
			# New local process
			ID = self.WorkersID
			self.WorkersID += 1
			
		else:
		
			ID = addr
			
			if(ID in self.AnalysisWorkers): 
			
				# Fallen worker reconnects before heartbeat detection
				sample = delAnalysisWorker(ID)
				self.WorkersLock.acquire()
				p = self.Workers[ID]
				self.WorkersLock.release()
				p.join()
				if sample != None: self.Digester.putSample(sample)
		
		p = Process(target=self.analysisWorkerProcess, args=(ID,addr))
		
		self.AnalysisWorkers[ID] = WorkerHandler(ID)
		
		self.WorkersLock.acquire()
		self.Workers[ID] = p
		self.WorkersLock.release()
		
		p.start()
		
		return ID
	
	
	def delAnalysisWorker(self, ID):
	
		if ID in self.AnalysisWorkers:
			return self.AnalysisWorkers[ID].stop()
			
		return None	
	
	def registerAnalysisWorkerHeartbeat(self, ID):
	
		self.AnalysisWorkers[ID].HBRegister()
		
		
	def getAnalysisWorkers(self):
	
		w = self.AnalysisWorkers.keys()
		return list(w)
		
		
	
	#########################################################
	#														#
	#					Labeling Workers					#
	#														#
	#########################################################
	
	def labelingWorkerProcess(self, ID, addr):
	
		try:
		
			if(self.LabelerMode == LabelerMode.Local):
				labeler = Labeler(LabelerMode.Local)
			else:
				labeler = cli.ServerProxy('http://{0}'.format(addr))
				labeler.system.listMethods()
			
			finished = self.LabelingWorkers[ID].markedForFinish()
			
			while(not finished):
			
				# Get log to parse
				(sampleID, log) = self.AvailableLogs.get()
				self.LabelingWorkers[ID].setResource((sampleID, log))
				
				# Submit the log for parsing
				results = labeler.SubmitLog(log)

				# Create the corresponding resource for the sample and save it
				self.Storer.CreateSampleResource(sampleID, "labeling.log", results)
				self.Storer.StoreSample(sampleID)
			
				# Marked for stop?
				finished = self.LabelingWorkers[ID].markedForFinish()
				self.LabelingWorkers[ID].setResource(None)
			
			self.LabelingWorkers[ID].done()
				
		except ConnectionRefusedError as err:
	
			resource = self.delLabelingWorker(ID)
			self.LabelingWorkers[ID].done()
			# Worker Disconnection -> Requeue the log to be labeled later
			if resource != None: self.AvailableLogs.put(resource)
	
	
	def addLabelingWorker(self, addr=None):
	
		if(self.LabelerMode == LabelerMode.Local):
		
			# New local process
			ID = self.WorkersID
			self.WorkersID += 1
			
		else:
			
			ID = addr
			
			if(ID in self.LabelingWorkers): 
			
				# Fallen worker reconnects before heartbeat detection
				resource = self.delLabelingWorker(ID)
				self.WorkersLock.acquire()
				p = self.Workers[ID]
				self.WorkersLock.release()
				p.join()
				if resource != None: self.AvailableLogs.put(resource)
		
		p = Process(target=self.labelingWorkerProcess, args=(ID,addr))
		
		self.LabelingWorkers[ID] = WorkerHandler(ID)
		
		self.WorkersLock.acquire()
		self.Workers[ID] = p
		self.WorkersLock.release()
		
		p.start()
		
		return ID
	
	
	def delLabelingWorker(self, ID):
	
		if ID in self.LabelingWorkers:
			return self.LabelingWorkers[ID].stop()
		
		return None
	
	
	def getLabelingWorkers(self):
	
		w = self.LabelingWorkers.keys()
		return list(w)
		
	
	def registerLabelingWorkerHeartbeat(self, ID):
	
		self.LabelingWorkers[ID].HBRegister()
	
	
