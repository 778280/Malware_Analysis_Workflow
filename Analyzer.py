#################################################################
#																#
# -Project:		Prevalence of Types of ASEPs in Windows malware #
# -File:		Analyzer.py										#
# -Author:		Carlos Borau Gonz√°lez | NIP: 778280				#
# -Description: Manages the dinamic analysis of malware samples #
#					via https://drakvuf-sandbox.readthedocs.io  #
#					by using https://karton-core.readthedocs.io #
#					API. Tools created by https://cert.pl/en 	#
#																#
#################################################################

# Drakvuf core imports
from karton.core import Producer, Config, Resource, Task
from drakrun.config import ETC_DIR
from drakrun.util import patch_config

# Utility imports
import requests
import enum
import json
import time
import os

from requests.exceptions import ConnectionError, HTTPError

# RPC comunication imports
import xmlrpc.server as srv
import xmlrpc.client as cli

class AnalyzerMode(enum.Enum):

    Local = 0
    Remote = 1
    

class Analyzer:

	
	check_url 	= "http://localhost:6300/status/{uid}"
	logs_url 	= "http://localhost:6300/logs/{uid}"
	log_url		= "http://localhost:6300/logs/{uid}/{log}"
	conf 		= patch_config(Config(os.path.join(ETC_DIR, "config.ini")))

	def __init__(self, mode, master_addr=None):
	
		if not (mode.name in AnalyzerMode.__members__):
			print("Analyzer mode not known:", mode)
			exit()
			
		self.Mode = mode
		
		if self.Mode == AnalyzerMode.Remote:
			self.Master = cli.ServerProxy('http://{0}/'.format(master_addr)) 
			
		self.Producer = Producer(self.conf)
		
		
	def SubmitSample(self, path, start_command=None, timeout=120, plugins=["syscalls"]):
	
		task = Task({"type": "sample", "stage": "recognized", "platform": "win64"})
		task.add_payload("override_uid", task.uid)
	
		# Add sample resource to task
		if(self.Mode == AnalyzerMode.Remote):
			sample_f = self.Master.requestFile(path)
		else:
			sample_f = open(path, "rb")
		
		sample = Resource("sample", sample_f.read())
		task.add_resource("sample", sample)
		
		# Add filename
		task.add_payload("file_name", os.path.splitext(path)[0])

		# Extract and add extension
		extension = os.path.splitext(path)[1][1:]
		if extension:
		    task.headers["extension"] = extension

		# Add start command
		if start_command is not None:
		    task.add_payload("start_command", start_command)

		# Add timeout
		task.add_payload("timeout", timeout)
		    
		# Add plugins
		task.add_payload("plugins", plugins)
		
		# Add analysis uuid  
		task.add_payload("analysis_uid", task.uid)
		
		self.producer.send_task(task)
		
		return task.uid
		
	
	def CheckStatus(self, task_uid):
		
		try:
		    r = requests.get(self.check_url.format(uid=task_uid))
		    r.raise_for_status()
		    return r.json()["status"]
		    
		except ConnectionError:
		    return "connection failed"
		except HTTPError:
		    return r.status_code
		    
	
	def AvailableLogs(self, task_uid):
	
		try:
		    r = requests.get(self.logs_url.format(uid=task_uid))
		    r.raise_for_status()
		    
		    r = r.content.decode('utf-8', 'ignore')
		    r = r.replace(task_uid+'/','')
		    logs = json.loads(r)
		    
		    return logs
		    
		except ConnectionError:
		    return []
		except HTTPError:
		    return []
		    
		    
	def GetLog(self, log):
	
		try:
		    r = requests.get(self.log_url.format(uid=task_uid,log=log))
		    r.raise_for_status()
		    
		    log_content = r.content.decode('utf-8', 'ignore')
		    
		    return log_content
		    
		except ConnectionError:
		    return ""
		except HTTPError:
		    return ""
