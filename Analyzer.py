#################################################################
#																#
# -Project:		Prevalence of Types of ASEPs in Windows malware #
# -File:		Analyzer.py										#
# -Author:		Carlos Borau Gonz√°lez | NIP: 778280				#
# -Description: Manages the dinamic analysis of malware samples #
#					via https://drakvuf-sandbox.readthedocs.io  #
#					by using https://karton-core.readthedocs.io #
#					API. Tools created by https://cert.pl/en 	#
#																#
#################################################################

# Utility imports
import requests
import enum
import json
import time
import sys
import os

from multiprocessing import Process
from requests.exceptions import ConnectionError, HTTPError

# Drakvuf core imports
from karton.core import Producer, Config, Resource, Task, Karton

try:

	from drakrun.config import ETC_DIR
	from drakrun.util import patch_config
	
except:

	sys.path.append('/opt/venvs/drakrun/lib/python3.8/site-packages/')
	from drakrun.config import ETC_DIR
	from drakrun.util import patch_config

# RPC comunication imports
import xmlrpc.server as srv
import xmlrpc.client as cli

class AnalyzerMode(enum.Enum):

    Local = 0
    Remote = 1
    
    
# Auxiliary class for karton task cleansing
class DrakrunAnalysisConsumer(Karton):
	identity = "karton.drakrun.archiver"
	filters = [
	    {
	        "type": "analysis",
	        "kind": "drakrun"
	    }
	]

	def process(self):
		analysis_uid = self.current_task.uid
		print("Pulled task: ", analysis_uid, end='\r', flush=True)
		

class Analyzer:


	check_url 	= "http://localhost:6300/status/{uid}"
	logs_url 	= "http://localhost:6300/logs/{uid}"
	log_url		= "http://localhost:6300/logs/{uid}/{log}"
	conf 		= patch_config(Config(os.path.join(ETC_DIR, "config.ini")))


	def __init__(self, mode, master_addr=None):
	
		if not (mode.name in AnalyzerMode.__members__):
			print("Analyzer mode not known:", mode)
			exit()
			
		self.Mode = mode
		
		if self.Mode == AnalyzerMode.Remote:
			self.Master = cli.ServerProxy('http://{0}/'.format(master_addr)) 
			
		self.Producer = Producer(self.conf)
		
		
	#########################################################
	#														#
	#				Analysis Task Cleansing					#
	#														#
	#########################################################
		
	def _PullTasks(self):
	
		conf = Config("/etc/drakrun/config.ini")
		consumer = DrakrunAnalysisConsumer(conf)
		consumer.loop()
	
	
	def Start(self):
	
		self.TaskPuller = Process(target=self._PullTasks, args=())
		self.TaskPuller.start()
		
	
	def Stop(self):
	
		self.TaskPuller.terminate()
		self.TaskPuller.join()
		
		
	#########################################################
	#														#
	#					 Sample Analysis					#
	#														#
	#########################################################
		
	def SubmitSample(self, path, start_command=None, timeout=120, plugins=["syscalls"]):
	
		task = Task({"type": "sample", "stage": "recognized", "platform": "win64"})
		task.add_payload("override_uid", task.uid)
	
		# Add sample resource to task
		if(self.Mode == AnalyzerMode.Remote):
			f = self.Master.RequestFile(path)
			sample = Resource("sample", f.data)
		else:
			f = open(path, "rb")
			sample = Resource("sample", f.read())
		
		task.add_resource("sample", sample)
		
		# Add filename
		task.add_payload("file_name", os.path.splitext(os.path.basename(path))[0])

		# Extract and add extension
		extension = os.path.splitext(path)[1][1:]
		if extension:
		    task.headers["extension"] = extension

		# Add start command
		if start_command is not None:
		    task.add_payload("start_command", start_command)

		# Add timeout
		task.add_payload("timeout", timeout)
		    
		# Add plugins
		task.add_payload("plugins", plugins)
		
		# Add analysis uuid  
		task.add_payload("analysis_uid", task.uid)
		
		self.Producer.send_task(task)
		
		return task.uid
		
	
	def CheckStatus(self, task_uid):
		
		try:
		    r = requests.get(self.check_url.format(uid=task_uid))
		    r.raise_for_status()
		    return r.json()["status"]
		    
		except ConnectionError:
		    return "connection failed"
		except HTTPError:
		    return r.status_code
		    
	
	def AvailableLogs(self, task_uid):
	
		try:
		    r = requests.get(self.logs_url.format(uid=task_uid))
		    r.raise_for_status()
		    
		    r = r.content.decode('utf-8', 'ignore')
		    r = r.replace(task_uid+'/','')
		    r = r.replace('.log','')
		    logs = json.loads(r)
		    
		    return logs
		    
		except ConnectionError:
		    return []
		except HTTPError:
		    return []
		    
		    
	def GetLog(self, task_uid, log):
	
		try:
		    r = requests.get(self.log_url.format(uid=task_uid,log=log))
		    r.raise_for_status()
		    
		    log_content = r.content.decode('utf-8', 'ignore')
		    
		    return log_content
		    
		except ConnectionError:
		    return ""
		except HTTPError:
		    return ""
