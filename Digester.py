#################################################################
#																#
# -Project:		Prevalence of Types of ASEPs in Windows malware #
# -File:		Digester.py										#
# -Author:		Carlos Borau Gonz√°lez | NIP: 778280				#
# -Description: Malware sample digester capable of interacting	#
#					with https://bazaar.abuse.ch/ api in order	#
#					to retrieve hourly sample batches to feed	#
#					the analysis pipeline. Samples may also be	#
#					manually placed in a specific directory so	#
#					they can be automaticly detected and then	#
#					injected into said pipeline					#
#																#
#################################################################

import requests
import pyzipper
import hashlib
import shutil
import queue
import time
import json
import csv
import os
import io
import re

from multiprocessing import Process, Value, Manager

class Digester:


	def __init__(self, overwatch_directory, samples_directory, processed_hashes=[]):
	
		if(not os.path.isdir(overwatch_directory)):
			print("Directory to watch over must exist and be accessible")
			exit()
		if(not os.path.isdir(samples_directory)):
			print("Directory to store the samples in must exist and be accessible")
			exit()
			
		if(os.path.abspath(overwatch_directory) == os.path.abspath(samples_directory)):
			print("Overwatch and Samples directories cannot be the same")
			exit()
			
	
		self.OverwatchDirectory = os.path.abspath(overwatch_directory)
		self.SamplesDirectory = os.path.abspath(samples_directory)
		self.SampleManager = Manager()
		self.ProcessedHashes = self.SampleManager.list(processed_hashes)
		self.AvailableSamples = self.SampleManager.Queue()
		self.Finished = Value('b', 1)
		
		# Constant parameters defined by implementation
		self.DownloadMethods = ["Last-Hour", "Last-2-Days"]
		self.AllowedFileExts = [".exe", ".dll"]
		
		
	#############################################################
	#															#
	#		Private Methods - Implementation dependant			#
	#															#
	#############################################################
	
	def _requestSamples(self, method):
	
		samples = []
		
		if(method == "Last-Hour"):
			data = {'query': 'get_recent', 'selector': 'time'}
			url  = 'https://mb-api.abuse.ch/api/v1/'
			response = requests.post(url, data=data, timeout=15)
			decoded_response = response.content.decode('utf-8', 'ignore')
			json_response = json.loads(decoded_response)
			if(json_response['query_status'] == 'ok'):
				json_response = json_response['data']
			else:
				json_response = ""
			
			
		elif(method == "Last-2-Days"):
			url = 'https://bazaar.abuse.ch/export/csv/recent/'
			response = requests.get(url, timeout=15)
			decoded_response = response.content.decode('utf-8', 'ignore')
			decoded_response = decoded_response.replace('# "', '"')
			decoded_response = re.sub(r'(?m)^ *#.*\n?$\n', '', decoded_response)
			decoded_response = decoded_response.replace('"', '')
			decoded_response = decoded_response.replace(' ', '')
			decoded_response = decoded_response.replace('file_type_guess', 'file_type')
			reader = csv.DictReader(io.StringIO(decoded_response))
			json_string = json.dumps(list(reader))
			json_response = json.loads(json_string)
			
		for sample in json_response:
			fileExt = '.' + sample['file_type']
			if(fileExt in self.AllowedFileExts):
			
				samples.append((sample['sha256_hash'], fileExt))
			
		return samples
		
		
		
	def _downloadSamples(self, samples):
	
		for (sha256, ext) in samples:
		
			if(not self.isProcessed(sha256)):
			
				data = {'query': 'get_file', 'sha256_hash': sha256}
				url = 'https://mb-api.abuse.ch/api/v1/'
				response = requests.post(url, data=data, timeout=15, allow_redirects=True)
				
				if(not 'file_not_found' in response.text):

					zipPath = '/tmp/' + sha256 + '.zip'
					
					open(zipPath, 'wb').write(response.content)
					
					with pyzipper.AESZipFile(zipPath) as zf:
						zf.pwd = b'infected'
						my_secrets = zf.extractall(self.SamplesDirectory)
						
					os.remove(zipPath)
				
					samplePath = os.path.join(self.SamplesDirectory, sha256 + ext)
					self.ProcessedHashes.append(sha256)
					self.AvailableSamples.put(samplePath)
	
	#############################################################
	#															#
	#		  Public Methods - Mandatory to Implement			#
	#															#
	#############################################################
		
	def getDownloadMethods(self):
	
		return self.DownloadMethods
	
	
	def getSample(self):
	
		try:
	
			return self.AvailableSamples.get(True, 15)
		
		except queue.Empty:
		
			return None
		
		
	def putSample(self, sample):
	
		self.AvailableSamples.put(sample)
	
	
	def isProcessed(self, sample_sha256):
	
		return sample_sha256 in self.ProcessedHashes
	
	
	def download(self, method):
	
		if(not method in self.DownloadMethods):
			print("Unknown download method ", method)
			return []
		
		samples = self._requestSamples(method)
		
		self._downloadSamples(samples)
				
		
	def checkLocalSamples(self):
	
		join = lambda file_name: os.path.join(self.OverwatchDirectory, file_name)
		files = [f for f in map(join, os.listdir(self.OverwatchDirectory)) if os.path.isfile(f)]

		for file_name in files:		
			ext = os.path.splitext(file_name)[-1]
			if(ext in self.AllowedFileExts):
				sha256 = hashlib.sha256()
				with open(file_name, "rb") as f:
					for byte_block in iter(lambda: f.read(4096), b""):
						sha256.update(byte_block)
				
				sha256 = sha256.hexdigest()
				
				if(not self.isProcessed(sha256)):
					samplePath = os.path.join(self.SamplesDirectory, sha256 + ext)
					shutil.copyfile(file_name, samplePath)
					self.ProcessedHashes.append(sha256)
					self.AvailableSamples.put(samplePath)
				
			os.remove(file_name)
		
		
	def overwatchLoop(self):
	
		while True:
		
			self.checkLocalSamples()
			
			time.sleep(self.UpdatePeriod)
		
		
	def start(self, update_period):
	
		self.UpdatePeriod = update_period
		self.loop = Process(target=self.overwatchLoop, args=())
		self.loop.start()
		
		
	def stop(self):
	
		self.loop.terminate()
		self.loop.join()
